# MyCollection

## Task

```
(i) ВНИМАНИЕ
НЕЛЬЗЯ ПОЛЬЗОВАТЬСЯ КОЛЛЕКЦИЯМИ JAVA ДЛЯ РЕШЕНИЯ ДОМАШНЕГО ЗАДАНИЯ
```

* **Задание 1 - ArrayList**<br><br>
  
  Написать свой класс `MyArrayList` как аналог классу `ArrayList`.<br><br>
  
  Можно использовать 1 массив для хранения данных.<br><br>
  
  Методы:

  * `add(Object value)` - добавляет элемент в конец
  * `remove(int index)` - удаляет элемент под индексом
  * `clear()` - очищает коллекцию
  * `size()` - возвращает размер коллекции
  * `get(int index)` - возвращает элемент под индексом
  <br><br>

* **Задание 2 - LinkedList**<br><br>

  Написать свой класс `MyLinkedList` как аналог классу `LinkedList`.<br><br>
  
  Нельзя использовать массив. Каждый элемент должен быть отдельным объектом-посредником(`Node` - нода) который хранит ссылку на предыдущий и следующий элемент коллекции (двусвязный список).<br><br>
  
  Методы:
  
  * `add(Object value)` - добавляет элемент в конец
  * `remove(int index)` - удаляет элемент под индексом
  * `clear()` - очищает коллекцию
  * `size()` - возвращает размер коллекции
  * `get(int index)` - возвращает элемент под индексом
  <br><br>

* **Задание 3 - Queue**<br><br>

  Написать свой класс `MyQueue` как аналог классу `Queue`, который будет работать по принципу _FIFO (first-in-first-out)_.<br><br>
  
  Можно делать либо с помощью `Node` либо с помощью массива.<br><br>
  
  Методы:
  
  * `add(Object value)` - добавляет элемент в конец
  * `remove(int index)` - удаляет элемент под индексом
  * `clear()` - очищает коллекцию
  * `size()` - возвращает размер коллекции
  * `peek()` - возвращает первый элемент в очереди (_FIFO_)
  * `poll()` - возвращает первый элемент в очереди и удаляет его из коллекции
  <br><br>

* **Задание 4 - Stack**<br><br>

  Написать свой класс `MyStack` как аналог классу `Stack`, который работает по принципу _LIFO (last-in-first-out)_.<br><br>
  
  Можно делать либо с помощью `Node` либо с помощью массива.
  
  Методы:
  
  * `push(Object value)` - добавляет элемент в конец
  * `remove(int index)` - удаляет элемент под индексом
  * `clear()` - очищает коллекцию
  * `size()` - возвращает размер коллекции
  * `peek()` - возвращает первый элемент в стеке (_LIFO_)
  * `pop()` - возвращает первый элемент в стеке и удаляет его из коллекции
  <br><br>

* **Задание 5 - HashMap**<br><br>

  Написать свой класс `MyHashMap` как аналог классу `HashMap`.<br><br>
  
  Нужно делать с помощью односвязной `Node`.<br><br>
  
  Не может хранить две `Node` с одинаковых ключами одновременно.<br><br>
  
  Методы:
  
  * `put(Object key, Object value)` - добавляет пару ключ + значение
  * `remove(Object key)` - удаляет пару по ключу
  * `clear()` - очищает коллекцию
  * `size()` - возвращает размер коллекции
  * `get(Object key)` - возвращает значение(Object value) по ключу
  <br><br>
